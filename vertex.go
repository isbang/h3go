// Copyright 2022  Il Sub Bang
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package h3go

// PentagonDirectionFaces is The faces in each axial direction of a given
// pentagon base cell.
type PentagonDirectionFaces struct {
	baseCell int                 // base cell number
	faces    [NUM_PENT_VERTS]int // face numbers for each axial direction, in order, starting with J
}

const (
	// Invalid vertex number
	INVALID_VERTEX_NUM = -1

	// Max number of faces a base cell's descendants may appear on
	MAX_BASE_CELL_FACES = 5
)

const (
	DIRECTION_INDEX_OFFSET = 2
)

// pentagonDirectionFaces is Table of direction-to-face mapping for each
// pentagon.
//
// Note that faces are in directional order, starting at J_AXES_DIGIT.
// This table is generated by the generatePentagonDirectionFaces script.
var pentagonDirectionFaces = [NUM_PENTAGONS]PentagonDirectionFaces{
	{baseCell: 4, faces: [NUM_PENT_VERTS]int{4, 0, 2, 1, 3}},
	{baseCell: 14, faces: [NUM_PENT_VERTS]int{6, 11, 2, 7, 1}},
	{baseCell: 24, faces: [NUM_PENT_VERTS]int{5, 10, 1, 6, 0}},
	{baseCell: 38, faces: [NUM_PENT_VERTS]int{7, 12, 3, 8, 2}},
	{baseCell: 49, faces: [NUM_PENT_VERTS]int{9, 14, 0, 5, 4}},
	{baseCell: 58, faces: [NUM_PENT_VERTS]int{8, 13, 4, 9, 3}},
	{baseCell: 63, faces: [NUM_PENT_VERTS]int{11, 6, 15, 10, 16}},
	{baseCell: 72, faces: [NUM_PENT_VERTS]int{12, 7, 16, 11, 17}},
	{baseCell: 83, faces: [NUM_PENT_VERTS]int{10, 5, 19, 14, 15}},
	{baseCell: 97, faces: [NUM_PENT_VERTS]int{13, 8, 17, 12, 18}},
	{baseCell: 107, faces: [NUM_PENT_VERTS]int{14, 9, 18, 13, 19}},
	{baseCell: 117, faces: [NUM_PENT_VERTS]int{15, 19, 17, 18, 16}},
}

// vertexRotations get the number of CCW rotations of the cell's vertex numbers
// compared to the directional layout of its neighbors.
func vertexRotations(cell H3Index) int {
	// Get the face and other info for the origin
	var fijk FaceIJK
	_h3ToFaceIjk(cell, &fijk)
	baseCell := H3GetBaseCell(cell)
	cellLeadingDigit := _h3LeadingNonZeroDigit(cell)

	// get the base cell face
	var baseFijk FaceIJK
	_baseCellToFaceIjk(baseCell, &baseFijk)

	ccwRot60 := _baseCellToCCWrot60(baseCell, fijk.face)

	if _isBaseCellPentagon(baseCell) {
		// Find the appropriate direction-to-face mapping
		var dirFaces PentagonDirectionFaces
		for p := 0; p < NUM_PENTAGONS; p++ {
			if pentagonDirectionFaces[p].baseCell == baseCell {
				dirFaces = pentagonDirectionFaces[p]
				break
			}
		}

		// additional CCW rotation for polar neighbors or IK neighbors
		if fijk.face != baseFijk.face &&
			(_isBaseCellPolarPentagon(baseCell) ||
				fijk.face ==
					dirFaces.faces[IK_AXES_DIGIT-DIRECTION_INDEX_OFFSET]) {
			ccwRot60 = (ccwRot60 + 1) % 6
		}

		// Check whether the cell crosses a deleted pentagon subsequence
		if cellLeadingDigit == JK_AXES_DIGIT &&
			fijk.face ==
				dirFaces.faces[IK_AXES_DIGIT-DIRECTION_INDEX_OFFSET] {
			// Crosses from JK to IK: Rotate CW
			ccwRot60 = (ccwRot60 + 5) % 6
		} else if cellLeadingDigit == IK_AXES_DIGIT &&
			fijk.face ==
				dirFaces.faces[JK_AXES_DIGIT-DIRECTION_INDEX_OFFSET] {
			// Crosses from IK to JK: Rotate CCW
			ccwRot60 = (ccwRot60 + 1) % 6
		}
	}
	return ccwRot60
}

// directionToVertexNumHex is hexagon direction to vertex number relationships
// (same face).
//
// Note that we don't use direction 0 (center).
var directionToVertexNumHex = [NUM_DIGITS]int{
	int(INVALID_DIGIT), 3, 1, 2, 5, 4, 0,
}

// directionToVertexNumPent is Pentagon direction to vertex number
// relationships (same face).
//
// Note that we don't use directions 0 (center) or 1 (deleted K axis).
var directionToVertexNumPent = [NUM_DIGITS]int{
	int(INVALID_DIGIT), int(INVALID_DIGIT), 1, 2, 4, 3, 0,
}

// vertexNumForDirection get the first vertex number for a given direction. The
// neighbor in this direction is located between this vertex number and the next
// number in sequence.
//
// Return the number for the first topological vertex, or INVALID_VERTEX_NUM if
// the direction is not valid for this cell.
func vertexNumForDirection(origin H3Index, direction Direction) int {
	isPentagon := H3IsPentagon(origin)
	// Check for invalid directions
	if direction == CENTER_DIGIT || direction >= INVALID_DIGIT ||
		(isPentagon && direction == K_AXES_DIGIT) {
		return INVALID_VERTEX_NUM
	}

	// Determine the vertex rotations for this cell
	rotations := vertexRotations(origin)

	// Find the appropriate vertex, rotating CCW if necessary
	if isPentagon {
		return (directionToVertexNumPent[direction] + NUM_PENT_VERTS -
			rotations) %
			NUM_PENT_VERTS
	} else {
		return (directionToVertexNumHex[direction] + NUM_HEX_VERTS -
			rotations) %
			NUM_HEX_VERTS
	}
}
